// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/*
  GrowFi simplified demo for AFL-2 assignment
  - Implements funding, collateral locking (ERC20), profit-sharing, and a governance hook
  - Demonstrates many Solidity features per rubric
*/

/* ============================
   Interfaces & Custom Errors
   ============================ */

interface IERC20Minimal {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function decimals() external pure returns (uint8);
}

/* custom errors (gas efficient) */
error NotOwner();
error NotProjectOwner();
error InvalidAmount();
error ProjectClosed();
error AlreadyCollateralized();
error NotInvestor();
error TransferFailed();
error ZeroAddress();
error Unauthorized();

/* ============================
   Simple Ownable (Inheritance example)
   ============================ */
abstract contract Ownable {
    address public owner; // state variable

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor(address initialOwner) {
        if (initialOwner == address(0)) revert ZeroAddress();
        owner = initialOwner;
    }

    modifier onlyOwner() {
        if (msg.sender != owner) revert NotOwner();
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        if (newOwner == address(0)) revert ZeroAddress();
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}

/* ============================
   Minimal GFI token (ERC20-like) - demonstrates Interface & Token usage
   ============================ */
contract GFI is Ownable {
    string public name = "GrowFi";
    string public symbol = "GFI";
    uint8 public constant DECIMALS = 18; // konstanta desimal
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    constructor(address initialOwner) Ownable(initialOwner) {
        // mint a small initial supply to owner for testing
        _mint(initialOwner, 1_000_000 * (10 ** uint256(DECIMALS)));
    }

    // decimals sekarang pure karena mengembalikan konstanta
    function decimals() external pure returns (uint8) {
        return DECIMALS;
    }

    function _mint(address to, uint256 amount) internal {
        balanceOf[to] += amount;
        totalSupply += amount;
        emit Transfer(address(0), to, amount);
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        require(balanceOf[msg.sender] >= amount, "insufficient");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        uint256 allowed = allowance[from][msg.sender];
        require(allowed >= amount, "allowance");
        require(balanceOf[from] >= amount, "bal");
        allowance[from][msg.sender] = allowed - amount;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        emit Transfer(from, to, amount);
        return true;
    }
}

/* ============================
   Governance Contract (simple DAO-like stub)
   - demonstrates enums, structs, mapping, arrays, events
   ============================ */

contract Governance is Ownable {
    enum VoteOption { Null, Yes, No }
    struct Proposal {
        string title;
        address proposer;
        uint256 votesYes;
        uint256 votesNo;
        uint256 deadline; // timestamp
        bool executed;
    }

    Proposal[] public proposals;
    mapping(uint256 => mapping(address => VoteOption)) public votes; // proposalId => voter => vote

    event ProposalCreated(uint256 indexed id, address indexed proposer, string title);
    event Voted(uint256 indexed id, address indexed voter, VoteOption option);
    event ProposalExecuted(uint256 indexed id);

    uint256 public constant VOTING_DURATION = 3 days; // constant example

    constructor(address initialOwner) Ownable(initialOwner) {}

    function createProposal(string calldata title) external returns (uint256) {
        proposals.push(Proposal({
            title: title,
            proposer: msg.sender,
            votesYes: 0,
            votesNo: 0,
            deadline: block.timestamp + VOTING_DURATION,
            executed: false
        }));
        uint256 id = proposals.length - 1;
        emit ProposalCreated(id, msg.sender, title);
        return id;
    }

    function vote(uint256 proposalId, VoteOption option) external {
        Proposal storage p = proposals[proposalId];
        require(block.timestamp <= p.deadline, "voting closed");
        require(option == VoteOption.Yes || option == VoteOption.No, "invalid");
        require(votes[proposalId][msg.sender] == VoteOption.Null, "already voted");

        votes[proposalId][msg.sender] = option;
        if (option == VoteOption.Yes) p.votesYes++;
        else p.votesNo++;

        emit Voted(proposalId, msg.sender, option);
    }

    function execute(uint256 proposalId) external {
        Proposal storage p = proposals[proposalId];
        require(block.timestamp > p.deadline, "not ended");
        require(!p.executed, "already");
        p.executed = true;
        // In a full system, here would be actual effecting of changes via multi-sig or a governance executor
        emit ProposalExecuted(proposalId);
    }

    // view helper
    function proposalCount() external view returns (uint256) {
        return proposals.length;
    }
}

/* ============================
   GrowFiFunding Contract - main logic
   ============================ */

contract GrowFiFunding is Ownable {
    /* ---------- Enums & Structs (used in rubric) ---------- */
    enum ProjectStatus { Open, Funded, Defaulted, Closed }

    struct Project {
        address owner;              // MSME
        string name;                // project name
        uint256 fundingGoal;        // in wei
        uint256 fundedAmount;       // in wei
        ProjectStatus status;
        address collateralToken;    // address of ERC20 used as collateral
        uint256 collateralAmount;   // amount of collateral (in token smallest unit)
        uint256 deadline;           // timestamp when project must repay or be considered default
        mapping(address => uint256) investments; // investor => amount invested
        address[] investors;        // array of investor addresses
    }

    /* ---------- State Variables (state, constants, immutables) ---------- */
    uint256 public constant PLATFORM_FEE_BP = 20; // basis points => 0.20% (20/10000)
    uint256 public immutable defaultRepayWindow;   // immutable set in constructor
    GFI public immutable gfiToken;                 // interface to GFI token (immutable)
    Governance public governance;                  // governance contract

    // projects will be stored as mapping to Project struct stored in storage
    uint256 public projectCounter;
    mapping(uint256 => Project) private projects;

    /* ---------- Events ---------- */
    event ProjectCreated(uint256 indexed projectId, address indexed owner, string name, uint256 goal, address collateralToken, uint256 collateralAmount);
    event Invested(uint256 indexed projectId, address indexed investor, uint256 amount);
    event CollateralLocked(uint256 indexed projectId, address indexed token, uint256 amount);
    event FundsReleased(uint256 indexed projectId, address indexed to, uint256 amount);
    event DefaultDeclared(uint256 indexed projectId);
    event Liquidated(uint256 indexed projectId, uint256 recoveredAmount);
    event Payout(uint256 indexed projectId, address indexed investor, uint256 amount);
    event ProfitDistributed(uint256 indexed projectId, uint256 totalProfit);

    /* ---------- Modifiers (demonstrates modifier usage) ---------- */
    modifier onlyProjectOwner(uint256 projectId) {
        if (msg.sender != projects[projectId].owner) revert NotProjectOwner();
        _;
    }

    modifier projectOpen(uint256 projectId) {
        if (projects[projectId].status != ProjectStatus.Open) revert ProjectClosed();
        _;
    }

    modifier onlyInvestor(uint256 projectId) {
        if (projects[projectId].investments[msg.sender] == 0) revert NotInvestor();
        _;
    }

    /* ---------- Constructor ---------- */
    constructor(address ownerAddress, GFI _gfiToken, Governance _governance, uint256 repayWindowDays) Ownable(ownerAddress) {
        if (address(_gfiToken) == address(0) || address(_governance) == address(0)) revert ZeroAddress();
        gfiToken = _gfiToken;
        governance = _governance;
        defaultRepayWindow = repayWindowDays * 1 days; // immutable
    }

    /* =============================
       Project lifecycle functions
       ============================= */

    // createProject shows structs, arrays, mapping usage and constructor-like init
    function createProject(
        string calldata name,
        uint256 fundingGoalWei,
        address collateralToken,
        uint256 collateralAmountToken,
        uint256 fundDurationDays
    ) external returns (uint256) {
        if (fundingGoalWei == 0 || collateralToken == address(0) || collateralAmountToken == 0) revert InvalidAmount();

        uint256 pid = projectCounter++;
        Project storage p = projects[pid];

        p.owner = msg.sender;
        p.name = name;
        p.fundingGoal = fundingGoalWei;
        p.status = ProjectStatus.Open;
        p.collateralToken = collateralToken;
        p.collateralAmount = collateralAmountToken;
        p.deadline = block.timestamp + (fundDurationDays * 1 days);

        emit ProjectCreated(pid, msg.sender, name, fundingGoalWei, collateralToken, collateralAmountToken);
        return pid;
    }

    // Investors fund the project sending ETH (payable)
    function fundProject(uint256 projectId) external payable projectOpen(projectId) {
        Project storage p = projects[projectId];
        if (msg.value == 0) revert InvalidAmount();

        // record investment
        if (p.investments[msg.sender] == 0) {
            p.investors.push(msg.sender);
        }
        p.investments[msg.sender] += msg.value;
        p.fundedAmount += msg.value;

        emit Invested(projectId, msg.sender, msg.value);

        // if fully funded, transition status and release funds after verifying collateral locked
        if (p.fundedAmount >= p.fundingGoal) {
            p.status = ProjectStatus.Funded;
            // release funds to project owner (but first enforce collateral locked)
            // the actual funds release is separated so MSMe must call lockCollateral to finish the flow
        }
    }

    // MSME must lock collateral (ERC20) by approve -> lockCollateral() (uses transferFrom)
    function lockCollateral(uint256 projectId) external onlyProjectOwner(projectId) {
        Project storage p = projects[projectId];
        if (p.collateralAmount == 0) revert InvalidAmount();
        if (p.collateralToken == address(0)) revert ZeroAddress();
        // prevent double-lock - a simple check; in production use per-project flag
        if (IERC20Minimal(p.collateralToken).balanceOf(address(this)) >= p.collateralAmount) revert AlreadyCollateralized();

        // transferFrom from project owner to contract
        bool ok;
        try IERC20Minimal(p.collateralToken).transferFrom(msg.sender, address(this), p.collateralAmount) returns (bool success) {
            ok = success;
        } catch {
            ok = false;
        }
        if (!ok) revert TransferFailed();

        emit CollateralLocked(projectId, p.collateralToken, p.collateralAmount);

        // If funded already, release funds now
        if (p.status == ProjectStatus.Funded) {
            _releaseFunds(projectId);
        }
    }

    // internal: transfer collected ETH (minus fee) to MSME
    function _releaseFunds(uint256 projectId) internal {
        Project storage p = projects[projectId];
        uint256 total = p.fundedAmount;
        // calculate platform fee (basis points)
        uint256 fee = (total * PLATFORM_FEE_BP) / 10000;
        uint256 payout = total - fee;

        // first, send fee to owner (platform)
        (bool sentFee, ) = owner.call{value: fee}("");
        require(sentFee, "fee transfer failed");

        // then send payout to MSME
        (bool success, ) = p.owner.call{value: payout}("");
        require(success, "payout failed");

        emit FundsReleased(projectId, p.owner, payout);
    }

    // Owner (or anyone) can declare default if deadline + repay window exceeded and not repaid
    function checkAndDeclareDefault(uint256 projectId) external {
        Project storage p = projects[projectId];
        require(p.status == ProjectStatus.Funded, "not funded");
        if (block.timestamp <= p.deadline + defaultRepayWindow) revert("not yet defaultable");
        p.status = ProjectStatus.Defaulted;
        emit DefaultDeclared(projectId);
    }

    // Liquidation: sell collateral (simulated by transferring collateral to platform owner)
    // demonstrates try/catch and token transfers
    function liquidateCollateral(uint256 projectId) external {
        Project storage p = projects[projectId];
        require(p.status == ProjectStatus.Defaulted, "not defaulted");

        uint256 collateral = p.collateralAmount;
        address token = p.collateralToken;
        // try to transfer collateral to platform owner and then distribute proceeds to investors
        bool ok;
        try IERC20Minimal(token).transfer(owner, collateral) returns (bool success) {
            ok = success;
        } catch {
            ok = false;
        }
        if (!ok) revert TransferFailed();

        // For demo: we assume collateral value equals amount in wei to be distributed
        uint256 recoveredAmount = 0; // in a real system you'd price tokens; here we distribute zero or a simulated amount
        // Distribute recoveredAmount proportionally
        uint256 investorsLen = p.investors.length;
        if (investorsLen > 0 && recoveredAmount > 0) {
            for (uint256 i = 0; i < investorsLen; i++) {
                address inv = p.investors[i];
                uint256 invShare = (p.investments[inv] * recoveredAmount) / p.fundedAmount;
                if (invShare > 0) {
                    (bool okSend,) = inv.call{value: invShare}("");
                    if (okSend) emit Payout(projectId, inv, invShare);
                }
            }
        }

        emit Liquidated(projectId, recoveredAmount);
    }

    // MSME can report profit and distribute (profit-sharing model)
    function distributeProfit(uint256 projectId) external onlyProjectOwner(projectId) payable {
        Project storage p = projects[projectId];
        require(p.status == ProjectStatus.Funded, "not funded");
        uint256 profit = msg.value;
        require(profit > 0, "no-profit");

        // take fee in GFI optionally (for demo we accept ETH fee)
        uint256 fee = (profit * PLATFORM_FEE_BP) / 10000;
        uint256 distributable = profit - fee;
        (bool sentFee, ) = owner.call{value: fee}("");
        require(sentFee, "fee failed");

        // distribute to investors proportionally
        uint256 invCount = p.investors.length;
        for (uint256 i = 0; i < invCount; i++) {
            address inv = p.investors[i];
            uint256 invShare = (p.investments[inv] * distributable) / p.fundedAmount;
            if (invShare > 0) {
                (bool ok,) = inv.call{value: invShare}("");
                if (ok) emit Payout(projectId, inv, invShare);
                // else skip failed individual transfer (could be improved)
            }
        }

        emit ProfitDistributed(projectId, profit);
    }

    /* =============================
       Getter and helper view functions (view & pure)
       ============================= */

    // view: returns basic project summary (example of view)
    function getProjectSummary(uint256 projectId) external view returns (
        address ownerAddr,
        string memory name,
        uint256 goal,
        uint256 funded,
        ProjectStatus status,
        address collateralToken,
        uint256 collateralAmount,
        uint256 deadline,
        uint256 investorCount
    ) {
        Project storage p = projects[projectId];
        ownerAddr = p.owner;
        name = p.name;
        goal = p.fundingGoal;
        funded = p.fundedAmount;
        status = p.status;
        collateralToken = p.collateralToken;
        collateralAmount = p.collateralAmount;
        deadline = p.deadline;
        investorCount = p.investors.length;
    }

    // view: check investment by an investor
    function getInvestmentOf(uint256 projectId, address investor) external view returns (uint256) {
        return projects[projectId].investments[investor];
    }

    // pure: calculate platform fee for a given amount
    function calculatePlatformFee(uint256 amountWei) public pure returns (uint256) {
        return (amountWei * PLATFORM_FEE_BP) / 10000;
    }

    /* =============================
       Admin / emergency functions
       ============================= */

    // Admin can close a project (demonstrate onlyOwner and assert)
    function closeProject(uint256 projectId) external onlyOwner {
        Project storage p = projects[projectId];
        p.status = ProjectStatus.Closed;
        // assert used to verify some invariant (here simple sanity check)
        assert(p.status == ProjectStatus.Closed);
    }

    // fallback to accept ETH if someone sends directly
    receive() external payable {}
    fallback() external payable {}
}
